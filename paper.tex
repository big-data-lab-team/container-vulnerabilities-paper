% GigaScience template
\documentclass[a4paper,num-refs]{oup-contemporary}

\journal{gigascience}
%%%% Packages %%%%
\usepackage{siunitx}
\usepackage{algpseudocode} % Algorithmic environment
\usepackage{xspace}
\usepackage{csvsimple}
\usepackage{minted} % Used for JSON highlighting
\usepackage{datatool}
\usepackage{booktabs}
\usepackage{xcolor}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{multirow}
\usepackage{array}
\usepackage{algorithm}
\usepackage{caption}
\usepackage[justification=centering]{caption}
\usepackage{subcaption}
\usepackage{listings}
\usepackage{verbatim}
\usepackage{adjustbox}
\usepackage{makecell}
\usepackage{titlesec}
\usepackage{anyfontsize}
\usepackage[flushleft]{threeparttable}

%%%% Commands %%%%
\newcommand{\todo}[1]{\color{red}\textbf{TODO:}#1\color{black}}
\newcommand{\change}[2]{\color{cyan}Changes: #1\color{black}}
\newcommand{\reprozip}[0]{ReproZip}
\newcommand{\rom}[1]{\lowercase\expandafter{\romannumeral #1\relax}}
\newcommand{\tristan}[1]{\color{blue}From Tristan: #1\color{black}}

\renewcommand{\labelitemi}{$\textendash$}
\title{Vulnerability Analysis of Container Images in Neuroimaging}
\begin{filecontents*}{resul.csv}
labels,names,A,C,V,Stools
a,bids/example:latest,838,663,683,
b,bids/freesurfer:latest,353,215,192,
c,bids/ndmg:latest,934,757,782,
d,\textbf{bids/broccoli:v1.0.0},79,79,117,
e,bids/fibredensityandcrosssection:latest,1086,849,868,
f,bids/spm:latest,191,246,235,
g,poldracklab/mriqc:0.15.0,432,328,332,
h,bids/cpac:v1.0.1a\_22,698,524,535,
I,bids/hyperalignment:latest,1717,1327,1433,
j,bids/mindboggle:0.0.4-1,671,955,569,
k,bids/mrtrix3\_connectome:latest,275,157,158,
l,bids/rs\_signal\_extract:0.1,867,454,473,
m,bids/aa:v0.2.0,189,244,233,
n,bids/niak:latest,1482,1366,1420,
o,bids/oppni:v0.7.0-1,913,698,723,
p,poldracklab/fmriprep:unstable,516,355,393,
q,bids/brainiak-srm:latest,897,484,503,
r,bids/nipypelines:0.3.0,641,878,451,
s,bids/hcppipelines:v3.17.0-18,526,873,620,
t,bids/magetbrain:latest,112,117,126,
u,bids/tracula:v6.0.0-4,874,664,683,
v,bids/baracus:latest,172,238,216,
w,bids/antscorticalthickness:v2.2.0-1,289,27,no data,
x,bids/dparsf:v4.3.12,507,750,757,
y,bids/afni\_proc:latest,67,16,no data,
z,bids/rshrf:1.0.1,5,3,3,
aa,bids/ndmg:v0.1.0,934,758,782,
ab,\textbf{mcin/qeeg:latest},46,46,142,
ac,\textbf{camarasu/creaphase:0.3},54,54,186,
ad,\textbf{bigdatalabteam/hcp-prefreesurfer:exec-centos7.freesurferbuild-centos4-latest:latest},70,76,157,
ae,\textbf{mcin/docker-fsl:latest},75,75,201,
af,gkiar/onevoxel:v0.3.0rc2,5,2,2,
ag,\textbf{bigdatalabteam/hcp-prefreesurfer:exec-centos7-fslbuild-centos5-latest:latest},70,76,157,
ah,\textbf{bt5e/ants:latest},150,156,336,
ai,poldracklab/fmriprep:1.2.3,591,441,447,
aj,gkiar/dwipreproc\_fsl-5.0.11\_minified:latest,391,258,263,
ak,gkiar/mask2boundary:v0.1.0,15,11,11,
al,\textbf{mcin/ica-aroma:latest},75,75,202,
am,c3genomics/genpipes,,,,99
an,bioinformatics-group/aqua-singularity-recipe,,,,7
ao,MontrealSergiy/BEst,,,,106
ap,shub://aces/cbrain-containers-recipes:fsl\_v6.0.1,,,,206
aq,shots47s/bids-freesurfer-6.0,,,,212
ar,shots47s/bids-fmriprep-1.2.3,,,,453
\end{filecontents*}
  
\begin{document}

\author[1]{Bhupinder Kaur}
\author[1]{Mathieu Dugr\'e}
\author[1]{Aiman Hanna}
\author[1]{Tristan Glatard}

\affil[1]{Department of Computer Science and Software Engineering, Concordia University, Montreal, Canada}
\maketitle

\begin{abstract}

Today, containers, which provide operating-system level virtualization, are
popular. Correspondingly, they are widely used for scientific data analyses on 
High Performance Computing (HPC) clusters. However, the security of containers
still remains a concerning issue. Here, we focus on the security of container
images, which are often built for the entire
duration of an analysis, so scientific researchers prefer not to update
them. Consequently, their chances of containing vulnerabilities increases.  
In this study, we analyze vulnerabilities in container images used in 
HPC clusters.
We conduct two different
experiments, image update and image minimization, to report the effect 
on the number of vulnerabilities.

\end{abstract}

\begin{keywords}
Containers; Docker; Singularity; Security Vulnerabilities; Neuroimaging.
\end{keywords}

\section{Introduction}

% Containers are popular on HPC, in particular Singularity
Software containers have emerged has an efficient solution to deploy
scientific data analyses on High Performance Computing (HPC) clusters, due
to their portability, ease of use, and limited overhead. The
Singularity~\cite{kurtzer2017singularity} framework is often preferred to
Docker\footnote{\url{http://docker.com}} on HPC clusters, due to its
secure handling of multi-user environments, and its convenient support for
Docker images. Singularity is now available in dozens of HPC
clusters around the globe, and used routinely for Big Data analyses.

% Containers are meant to isolate applications from the host, but security remains an issue
Using core features of the Linux kernel such as namespaces, control groups
and chroot, containers isolate processes from the
host computer,  
and control the memory, CPU, network and file-system resources assigned to
them. However, containers still share the kernel, mounted file systems and
some devices with the host, which raises potential security issues. In
particular, privilege escalation, denial of service and information leak
are always plausible~\cite{gantikow2016providing}. Therefore, security remains 
an important concern when deploying containers~\cite{bettini2015vulnerability}.

% Container images, our study
This study is a vulnerability analysis of container images used in HPC
clusters. Container images contain complete operating-system distributions, including
the data analysis software and its required dependencies.
Images are rarely updated, as they are often built once
for the entire duration of an analysis, to avoid results perturbations
coming from software updates~\cite{gronenschild2012effects, glatard2015reproducibility}. Images also
commonly include more dependencies than required by a specific analysis, to 
enable reusability across experiments.

Our research questions are the following:

\textit{RQ1: What is the current amount of known vulnerabilities in
container images deployed on HPC clusters?} Vulnerabilities are possible
attack vectors that may seriously compromise the security of HPC clusters
and the integrity of user data. We report vulnerability analyses produced
by four popular image scanning tools, Anchore, Vuls, Clair, and Stools.

\textit{RQ2: Can the amount of vulnerabilities be reduced by updating the images?}  
For many reasons related to reproducibility and the life-cycle of research
projects, container images deployed on HPC clusters often include outdated
software. We report on the effect of software updates on the vulnerability
analysis of RQ1.

\textit{RQ3: Can the amount of vulnerabilities be reduced by minimizing the images?} 
Container images often include more software packages than required for a
typical analysis. We report on the impact of this additional software on
the presence of vulnerabilities.

We answer these questions taking the particular example of neuroimaging, a
domain that has entered the Big Data era as many other
ones~\cite{van2014human}. We focus on the analysis of container images
present in BIDS apps~\cite{gorgolewski2017bids} and Boutiques~\cite{glatard2018boutiques}, two containerized
application frameworks commonly used in neuroimaging. 

The next section describes the materials and tools used in the experiments,
including container images and image scanners. We then describe our image
update and minimization methodology to reduce vulnerabilities. Results review
the detected vulnerabilities in container images, explain observed
discrepancies between scanners, and report on the efficiency of image
update and size reduction. As a conclusion, we provide a set of image
creation guidelines for a secure deployment on HPC clusters.

The existing research work on containers focuses mainly on the security of containers.
This focus is justified by the fact that containers expose the host's resources
(e.g., file system/ IPC) to the guest system. This feature raises a confidentiality
threat for the applications running on the same host. Previous studies evaluated
the security of Docker engine ~\cite{martin2018docker, sultan2019container, combe2016docker, bui2015analysis}.
Other work studied security vulnerabilities in Docker images. A study in 2015 by Gummaraju et al.
states that over 30\% of official images in docker hub contain high priority 
security vulnerabilities~\cite{gummaraju2015over}. Shu et al. show that both official and community images 
contain more than 180 vulnerabilities on an average~\cite{Shu2017}.
Zerouali et al. studied that 
outdated packages lead to bugs and severity vulnerabilities in Docker
images~\cite{zerouali2019relation}.

\section{Materials and Tools}

Since the aim of this research work is to detect security vulnerabilities
in container images and attempt to examine the effect of different
manipulations on these images, it is needed to have a representative set of
images. Additionally, for the purpose of detecting vulnerabilities,
utilization of image scanners is required. We utilize container
images from two popular application frameworks, as well as
four of the main image scanners.

\subsection{Container Images}

We scan all container images, available at the time of this study, on two containerization frameworks
used in neuroscience: BIDS
apps~\cite{gorgolewski2017bids} and Boutiques~\cite{glatard2018boutiques}, totalling
44 container images.
Out of these 44 images, 26 were obtained from BIDS apps
(\url{https://bids-apps.neuroimaging.io/apps/}) 
and 18 from Boutiques. In fact, at the time of the study, BIDS apps had 27 images,
out of which one wasn't available on DockerHub. Boutiques had 49 images,
%listed using Boutiques \texttt{bosh search} command,
however, only 23 unique images were listed, out of which 3 couldn't be retrieved and 2
were already included in BIDS apps. All the final 26 images
from BIDS apps are Docker images, whereas Boutiques contains 18 Docker images
and 6 Singularity images.

\subsection{Image Scanners}

We use four popular image scanners, namely Anchore~\cite{github_2019},
Vuls~\cite{future-architect_2019}, Clair~\cite{arminc_2019} and
Singularity Container Tools --- Stools~\cite{stools}. Anchore, Vuls and Clair support Docker
images while Stools support Singularity. Different vulnerabilities may be
reported by scanners if scanning experiments take place on different dates.
To avoid such discrepancies, we freeze the vulnerability
databases used by these scanners as of 2019-09-25, when we initiate our
experiments. This allows for a fair comparison between the scanners.

\subsubsection{Anchore}

Anchore is an end-to-end, open-source container security platform. It
analyze	container images and lists OS
packages, non-OS packages (Python, Java, Gem, and Npm), and files.
In our experiments, we use Anchore Engine version 0.5.0 through Docker image \texttt{anchore/anchore-engine:v0.5.0}, and
Anchore vulnerability database version 0.0.11.

Anchore compares package versions, which are present inside the
image, with the vulnerability database in order to flag vulnerabilities.
To get a vulnerability feed of various OS distributions, Anchore refers to
different sources. Table~\ref{database} displays Anchore's vulnerability sources for
Ubuntu, Debian, Alpine, and Centos, which are present inside taken images.
Anchore also refers to National
Vulnerability Database (NVD) to get metadata of vulnerabilities.

\begin{figure*}
\begin{tabular}{|c|c|c|c|}
 \hline
\textbf{OS} &	\textbf{Anchore} &	\textbf{Vuls} &	\textbf{Clair} \\
\hline
	\textbf{Alpine} & Alpine-SecDB &	Alpine-SecDB &	Alpine-SecDB \\
\hline
	\textbf{CentOS} & Red Hat OVAL Database & Red Hat OVAL Database and Red Hat Security Advisories & Red Hat Security Data \\
\hline
	\textbf{Debian} & Debian Security Bug Tracker &	Debian OVAL Database and Debian Security Bug Tracker & Debian Security Bug Tracker \\
\hline
	\textbf{Ubuntu} & Ubuntu CVE Tracker &	Ubuntu OVAL Database &	Ubuntu CVE Tracker \\
 \hline
\end{tabular}
\caption{Vulnerability databases used by scanners for different OS distributions}
\label{database}
\end{figure*}

\subsubsection{Vuls}

Vuls is an open-source vulnerability scanner for Linux and FreeBSD. It
offers both static and dynamic scanning, and both local and remote
scanning. In our experiments, we use remote dynamic scanning, that is, Vuls
connects to the running containers that needs to be scanned through SSH, and queries the package manager
in the container. We use Vuls 0.9.0, executed through Docker image
\texttt{vuls/vuls:0.9.0}. At the time of this study, Vuls gets vulnerability feed
from a configured set of sources. Table~\ref{database} lists vulnerability databases
referred by Vuls for scanned four OS distributions i.e. Alpine, Ubuntu, Debian, and Centos.
Apart from this, like Anchore, Vuls also refers NVD database for getting vulnerability metadata.
Table~\ref{database} shows that Vuls
refers to Open Vulnerability and Assessment Language (OVAL) database for Ubuntu, Debian, and Centos.
It is worth noting that there is
no vulnerability data for Ubuntu 17.04 and 17.10 distributions in OVAL database, meaning that images
with these distributions cannot be scanned with Vuls.

\subsubsection{Clair}

Clair (\url{https://github.com/quay/clair}) is an open-source and extensible
vulnerability scanner for Docker and appc container images, developed by
CoreOS (now Container Linux), a Linux distribution to deploy container
clusters. Clair has a client-server architecture, in which the server
scans Docker images layer by layer and maintains a database of vulnerabilities. We use Clair through Clair-scanner
(\url{https://github.com/arminc/clair-scanner}), a tool to facilitate the testing
of container images against a local Clair server. Clair-scanner scans the image,
prepares a list of vulnerabilities, compares that list against a
whitelist, and flags vulnerabilities that are not present in the whitelist.
In our experiments, we did not use a whitelist to filter scanning results in
order to make a fair comparison between scanners.
Clair-scanner maintains a Docker image with the up-to-date vulnerability
database from a set of different sources. Table~\ref{database} lists
vulnerability databases that Clair referred for Alpine, Ubuntu, Debian, and Centos.
Clair also uses NVD database for getting vulnerability metadata.
We use Clair version 2.0.6, executed through
Docker image \texttt{arminc/clair-local-scan:v2.0.6}. For the vulnerability
database, we use Docker image \texttt{arminc/clair-db:latest}, last
updated on 2019-09-18.

\subsubsection{Singularity Tools}

Singularity Tools (Stools)
are an extension of Clair for Singularity images. Stools
exports Singularity images to \texttt{tar.gz} format, acting as a single layer Docker image
to circumvent the Docker-specific requirements in the Clair API.
In our experiments, we use Singularity Tools version 3.2.1 through Docker
image
\texttt{vanessa/stools-clair:v3.2.1}, which is using another Docker
image \texttt{arminc/clair-db:latest} for referring to vulnerability feed.
Since Stools uses Clair internally for scanning, vulnerability databases used
by Stools are same as mentioned for Clair.
To scan Singularity images, we follow the steps mentioned in
\href{https://github.com/singularityhub/stools}{Stools Github}.

\subsection{Ubuntu Release types and its Vulnerability statuses}

BIDS apps and Boutiques images in our experiments have four Linux
distributions i.e. Ubuntu, CentOS, Debian, and Alpine. 
Out of these distributions, Ubuntu assigns a vulnerability status to
all vulnerabilities before keeping them in its vulnerability database.
Each vulnerability is assigned a unique Common Vulnerabilities and Exposures (CVE) number
by the MITRE corporation, who maintains a list of all vulnerabilities of all distributions.
Ubuntu keeps a record of Ubuntu-specific vulnerabilities in Ubuntu CVE Tracker using their CVE
numbers. In this paper, we use vulnerability and CVE interchangeably.
The vulnerability status in Ubuntu CVE Tracker is subjected to change
depending on the work progress to fix that vulnerability.
%Regarding Ubuntu, it has different
%types of releases e.g. Regular, Long Term Support (LTS), and Extended Security Maintenance (ESM) release.
%Ubuntu maintains its vulnerability data in Ubuntu CVE tracker, which is referred by Anchore and Clair.
%There is another vulnerability database i.e. Open Vulnerability and Assessment Language (OVAL) repository,
%which is maintained by MITRE corporation. Vuls refers to OVAL repository for getting Ubuntu vulnerability feed.
%The vulnerability data format of both databases is different. OVAL keeps a separate xml file for each release,
%which contains that release specific vulnerability information.
Ubuntu keeps a separate file for each vulnerability, which
has an entry for all Ubuntu releases combined with the current status
of that vulnerability in that release.
Further, in Ubuntu a particular release can be of different types i.e. Regular, Long Term Support (LTS), and Extended Security Maintenance (ESM) release. 
Through our experiments, we find that Anchore and Clair report Ubuntu vulnerabilities 
differently depending on either the different Ubuntu release type or vulnerability status. It is 
important to provide an overview of these Ubuntu releases types and vulnerability statuses, 
since Ubuntu is heavily utilized in our experiments. 
Ubuntu's Regular release is supported only for 9 months, whereas LTS is supported for 5 years. Once LTS support
reaches End-Of-Life (EOL), Ubuntu decides whether to provide extended security support or not, which comes
in the form of ESM release.
ESM is a paid service that can be requested from Ubuntu to get security 
updates even after the EOL of a particular Ubuntu release. ESM and LTS releases of a particular Ubuntu version have different vulnerability
databases, because after EOL of a release, a vulnerability is fixed only in packages of ESM; however, it still
exists in LTS.

As an example, Ubuntu has ended support for some releases, such as 14.04 LTS,
17.04, and 17.10, as they reached EOL. However, Ubuntu decided to provide optional extended support for Ubuntu 14.04.
To use this extended support, users have to purchase Ubuntu 14.04 ESM release.
The images in our experiments have Ubuntu 14.04 LTS, so scanners should refer
to LTS release only while collecting data from the vulnerability databases.
More interestingly, Clair refers to ESM release vulnerability database, however, this may lead to discrepancies in results.
Further, if an image is using a Linux release where EOL has been reached that image may
turns to be vulnerable as it is not possible to retrieve any updates.

In Ubuntu CVE Tracker, all Ubuntu releases are listed with the package name
in which vulnerability exists and are entitled a vulnerability status
(\url{https://git.launchpad.net/ubuntu-cve-tracker/plain/README}), which is
encoded in the following form:
\newline \\
\noindent <release>\_<source-package>: <status> (<version/notes>) \\
\newline\\
For a given release, the vulnerability status can be any one of the following:

\textbf{DNE (Does Not Exist):} The package does not exist in the
		archive.

\textbf{needs-triage:} The vulnerability of this package
		is not known, and hence evaluation is needed.

\textbf{not-affected:} The package, while related to the
		CVE in some way, is not affected by the issue. The <notes> should
		provide detailed information, if needed. For instance, if the given
		status is "not-affected (1.14.6-1.1)" then this indicates that this specific
		package version is not affected.

\textbf{needed:} The package is vulnerable to the
		CVE and needs to be fixed.

\textbf{active:} The package is vulnerable to the
		CVE, needs fixing, and is actively being worked on.

\textbf{ignored:} The package, while related to the
		CVE in some way, is being ignored for some reason. The
		<notes> should provide that reason. For instance, if status looks like
		"ignored (reached end-of-life)", this means that the given Ubuntu release already reached
		end-of-life, so this CVE is ignored by Ubuntu. However, if there
		is extended security support for this release then this
		CVE will be handled in ESM release.

\textbf{pending:} The package is vulnerable and
                  has been fixed but an update has not been yet uploaded or
		  published. The <version> is given to indicate the particular 
		  version where the fix has been done.

\textbf{deferred:} The package is vulnerable, but 
                   its fix has been deferred for some reason. The <notes>
		   should provide further details. If a date is mentioned, e.g.
		   "deferred (2015-02-02)", the given date specifies the date when
		   the CVE was deferred.

\textbf{released:} The package was vulnerable, but
		an update has been already uploaded and published, e.g. "released (1.2.3)",
		<version> indicates the first version where the fix was applied.

\textbf{released-esm:} The package was vulnerable and
		an update has been already uploaded and published. However,
		this update is published in the Ubuntu ESM release only and not in LTS.
		The fixed version of such packages is appended by either
		+esm or \char`\~esm, indicating that this package version is available
		only via ESM.

Figure~\ref{example} illustrates how the information of a CVE is represented
in the Ubuntu CVE Tracker.

\begin{figure}[!ht]
	\fbox{{\includegraphics[scale=2.5,width=\columnwidth]
	{Figures/vulnExample2.png}}}
        \caption{\label{example} Representation of a CVE in Ubuntu CVE Tracker}
\end{figure}
\vspace*{-7mm}
\section{Reducing the amount of vulnerabilities}

In this section, we present our approach to reduce the number of
vulnerabilities in container images  by updating and minimizing these
images.
\vspace*{-2mm}
\subsection{Image Update Process}

If vulnerabilities exist in the container images, then our first approach
is to update these images in order to see the effects of such updates
on the vulnerabilities.
Updating an image involves updating all software packages that are
inside that image. We use a 
\href{https://github.com/kaurbhupinder/Vulnerability-Analysis/blob/master/Scripts/update/update.sh}{bash script} 
to update all images. That script checks the
package manager, which is present inside the image, and updates the image
accordingly. However, this action affects the reproducibility
of that image. For example, if a package is used in an experiment
and later that package is updated, subsequent instances of the experiment may actually
get different results.
\vspace*{-2mm}
\subsection{Image Minimization Process}

We revert to image minimization to reduce the number of vulnerabilities without affecting results reproducibility.
An interesting choice to do so would be to use 
Neurodocker~\cite{neurodocker}.
This tool traces and deletes unnecessary files.
However, it does not affect the number of installed packages.
Since image scanners report vulnerabilities according to the installed
packages. Therefore, after
minimization the same number of vulnerabilities is still reported.
Consequently, we need to reduce the number of installed packages
in the images by deleting unnecessary packages. For that, it is required to figure
out which packages we need for the pipeline to function properly. To allow for that, we utilize
Reprozip~\cite{rampin2016reprozip}, an open-source tool that
helps scientists to make their research reproducible. This tool traces operating system calls used by the
application during execution, and then based on this trace, it recognizes binaries, files, environment variables,
and library dependencies that are used by the application for future re-execution. If the OS is
Debian or RPM-based, Reprozip also
uses an available package manager to acquire a list of distribution packages from where these files come from.
So, a list of packages that are needed for the application re-execution is determined. We run applications
using specific command lines given on application's Github repository in order to collect Reprozip trace.
These command lines represent how applications should be used.
Following that, the list
is expanded by adding important and required packages that are essential
for the system to function. Finally, we figure out all the dependencies of these packages using Debtree
~\cite{debtree}, which is avaiable in Debian and Ubuntu. It's alternative in Centos is Repoquery (\url{https://linux.die.net/man/1/repoquery}), which
gives a complete dependency tree of a particular package.
Effectively all needed packages are kept and remaining unnecessary packages are removed. We use
\href{https://github.com/kaurbhupinder/Vulnerability-Analysis/tree/master/Scripts/minification}{bash scripts} for
the image size reduction process, which install Reprozip in the image, collect Reprozip trace, and
finally delete all unnecessary packages.

Following the two previous approaches, we employ a hybrid approach, where
we combine both update and size reduction processes in an attempt to
lessen number of vulnerabilities or to test the effect of
combining two approaches. To allow for that, we first update all packages in
the image, then delete all unnecessary packages. Applying these processes in reverse
may reduce the needed work; however this is not possible in all cases. For instance,
some packages, such as \texttt{apt-transport-https}, are required to fetch updates, deleting these packages
ahead of time will disallow the update process to take place.
\vspace*{-2mm}
\section{Results}

In this section,
we first discuss the detected vulnerabilities in the images and compare the
results. We then discuss the effect of updating/minimizing the image and applying the hybrid
approach on the detected vulnerabilities.
Lastly, we do an analysis of obtained results and explain the reasons behind our
findings.
\vspace*{-2mm}
\subsection{Detected Vulnerabilities}

Table~\ref{table1} shows the number of vulnerabilities in the different images,
detected by each of the scanners. Image labels from a to al represents
Docker images, whereas remaining ones belong to Singularity.
Vuls shows \textit{no data} for images \texttt{bids/antscorticalthickness:v2.2.0-1} and \texttt{bids/afni\_proc:latest},
which have Ubuntu 17.04 and 17.10 OS distribution respectively. This is because there is no
vulnerability data present in OVAL database, which Vuls refers for Ubuntu distributions, for these two releases.

Figure~\ref{fig:graph1} provides more image-specific information.
It represents the number of vulnerabilities that are present inside each images.
The overall trend shows that as the number of packages increases in the image, the number of vulnerabilities
also get increased.
This Figure also infers that the Alpine distribution, being a
lightweight distribution, has the least number of vulnerabilities, whereas more vulnerabilities are reported for
distributions with more packages such as Ubuntu.
We also analyze that out of the total Docker images scanned by our experiments, Debian reports more high-level vulnerabilties, as
classified by databases, than others.
\begin{table*}
\csvreader[%
 tabular={|c|c|c|c|c|c|},
	table head = \hline\textbf{Labels} &\textbf{{Image names}} & \textbf{Anchore} & \textbf{Clair} & \textbf{Vuls} & \textbf{Stools}\\\hline,
	late after line= \\,
        late after last line=\\\hline %
	]{resul.csv}{labels=\labels,names=\names,A=\A,C=\C,V=\V,Stools=\Stools}%
        {\labels & \names & \A & \C & \V & \Stools}
       \centering
	\vspace*{1mm}
	\caption{\label{table1}Number of vulnerabilities by scanners (all Centos images are highlighted)} 
\end{table*}

\begin{figure*}
        {\includegraphics[scale=1.5,width=\textwidth]
        {Figures/vulngraph.pdf}}
	\vspace*{-7mm}
        \caption{\label{fig:graph1} Number of vulnerabilities by packages}
      \end{figure*}

\begin{figure}
        {\includegraphics[scale=2.5,width=\columnwidth]
        {Figures/venn.pdf}}
	\vspace*{-10mm}
	\caption{\label{fig:venn} Scanner results (excluding non-comparable image results)}
\end{figure}

\subsection{Discrepancies between Scanners}

Our experiments concluded considerable discrepancies in the results obtained by
these scanners. %We higlighted all Centos images in the Table~\ref{table1} since.
While comparing scanner results, we exluded all Centos images (highlighted images in Table~\ref{table1})
and two other images \texttt{bids/antscorticalthickness:v2.2.0-1} and
\texttt{bids/antscorticalthickness:v2.2.0-1}. The reason behind excluding Centos images is that scanners report results using different
vulnerability identifiers for Centos. Anchore and Clair use Red Hat Security Advisories (RHSAs)
to report pending patches that need to be applied to specific packages,
whereas Vuls uses Common Vulnerabilities and Exposures (CVE) number to report
vulnerabilities in packages. We exluded other two images because Vuls
can not scan these image, hence no results are present to compare.
In most cases,
Anchore reports more vulnerabilities than Vuls and Clair resulting in 
the Jaccard coefficient of 0.59 with both,
whereas Vuls and Clair share more common vulnerability detection resulting to the Jaccard coefficient of 0.83.
Figure~\ref{fig:venn} represents the number of vulnerabilities reported by
the scanners in Docker images and the overlap between them.
This Figure also excludes Centos Docker images and other two non-comparable images.
It is interesting to note that out of all reported vulnerabilities, 4453 vulnerabilities are only
reported by Anchore, 673 by Clair, and 325 by Vuls.

As the number and type of vulnerabilities reported by the these scanners are significantly different from each other,
we desire to investigate the reasons behind these differences.
Following our investigation, we are able to explain some of the reasons behind
the differences. 
Such reasons were resulted from the way these scanners function or behave 
in particular, the following actions by the scanners are indicative:
\begin{itemize}
   \item scanners ignoring vulnerabilities in Linux-kernel-header packages,
   \item scanners referring to different vulnerability databases,
   \item different frequency of updating their databases,
   \item bugs in scanners. 
\end{itemize}

Below, we explain these reasons in further details and provide examples
for clear illustrations.

\textbf{Linux-kernel-headers:} Clair and Vuls ignore all vulnerabilities in the Linux-kernel-headers,
whereas Anchore reports all of them.
We find that 4443 out of 4453 vulnerabilities that are only reported by Anchore are present in Linux-kernel-headers.
For example, CVE-2019-9506 present in Linux-libc-dev-4.4.0-31.50, reported by Anchore, is not
detected by both Vuls and Clair.
Linux-kernel-headers are the header files that only provide function names, their parameters, and their
return types.
The actual source code of those functions is present in the Linux kernel and is not inside the image.
So, vulnerability detection in header files
is irrelevant in this case.

\textbf{Ubuntu CVEs with status as “Not-affected”:} Vuls reports vulnerabilities that have status
as "not-affected" in the Ubuntu database. It means that according to Ubuntu the image is not affected
by the particular vulnerability. In other words, Vuls reports vulnerabilities that it should not have been reported.
For example, when we scan an image having the Trusty release in it and Vuls reports CVE-2015-2305
in the package Cups. However, upon checking the Ubuntu vulnerability database, we find that package Cups in Trusty is not
affected by this CVE.

\textbf{Ubuntu CVEs with status as "Ignored (reached end-of-life)":}
Some vulnerabilities are ignored in Ubuntu 14.04 LTS as it reached end-of-life. 
However, in Ubuntu 14.04 ESM release, these vulnerabilities may or may not be present.
Anchore checks the last status of these vulnerabilities whether the package was vulnerable to the CVE
prior to the end-of-life. Only if it was vulnerable, Anchore reports it, otherwise it does not.
If this kind of vulnerability is present in ESM release then Clair reports it because it
only refers to ESM release. On the other hand, if the vulnerability
status in ESM release is "DNE" (Does Not Exist), then Clair does not report it. 
For example, CVE-2017-9994 vulnerability in Libav package is ignored in Trusty LTS release due to its end-of-life.
Consequently, it is not reported by Anchore. This vulnerability has status as "DNE" in Trusty ESM
release so Clair also does not report it. As Ubuntu 14.04 LTS release is present inside the images,
Clair's referring to Ubuntu 14.04 ESM release vulnerability database is incorrect.

\begin{figure*}[!ht]
        {\includegraphics[width=\textwidth]
        {Figures/vulnwithupdate.pdf}}
	\vspace*{-7mm}
        \caption{\label{fig:graph2} Number of vulnerabilities before and
        after update of the images}
      \end{figure*}


\begin{figure*}[!ht]
        {\includegraphics[scale=1.5,width=\textwidth]
        {Figures/bargraph.png}}
	\vspace*{-5mm}
        \caption{\label{fig:bargraph} Vulnerabilities by different experiments}
      \end{figure*}
\textbf{Vulnerabilities not present in Ubuntu 14.04 ESM release:} These vulnerabilities are not present in Ubuntu 14.04 ESM so they 
are not detected by Clair but they affect Ubuntu 14.04 LTS, and hence detected by Vuls and Anchore. The CVE-2017-13758 is an example
of such vulnerabilities.

\textbf{Misses:} Clair and Vuls
missed vulnerabilities that they should have detected. For example, the CVE-2016-9082 
is present in package Cairo in Xenial release and it is not detected by Clair.
Vuls also missed vulnerabilities such as CVE-2019-5094.

\textbf{Wrong Detections:} 
Some vulnerabilities are not linked to Ubuntu 14.04 LTS which is 
present inside the image, however, Clair have reported such vulnerabilities.
For instance, CVE-2019-1274 is an example of such vulnerabilities. 
%is showing because these vulnerabilities are present in Ubuntu 14.04 ESM and 
%Clair is only referring to Ubuntu 14.04 ESM release. 
We reported this issue on two Google groups of Clair i.e. CoreOS Dev and
clair-dev \url{(https://groups.google.com/forum/\#!topic/clair-dev/8IqCCfd-EEc).}

\textbf{Database difference:} At the time we pulled Clair's database, through \texttt{arminc/clair-db:latest} Docker image, it was one week old.
                              As a result some vulnerabilities were not updated in the database. For instance, CVE-2019-5094, which
		              was published on 2019-09-24, was not 
		              updated in Clair's database. Due to which it is missed by Clair.
			      Consequently, these discrepancies, even small, are sufficient to change the detection of
			      the scanners.

\textbf{Epoch bug:} There is a bug in the Anchore scanner due to which some vulnerabilities are 
		not detected by Anchore. This bug gets triggered when a package’s version have epoch 
		(1:3.3.9-1ubuntu2.3) in it. For example, CVE-2018-1125 in Procps package is not
		detected by Anchore due to the presence of epoch in the Procps package version.
		We reported this bug to the Anchore development team through their Slack channel.

\textbf{Ubuntu CVEs with status "Ignored (out of standard support)" bug:} There is another bug in Anchore due to 
		which it is not able to detect some vulnerabilities. Due to this bug, Anchore does not detect 
		vulnerabilities that have a status as “ignored (out of standard support)” in Ubuntu 14.04 LTS. 
		However, if this vulnerability is present in Ubuntu 14.04 ESM release, it is detected by Clair. 
		For instance, CVE-2019-13565, which is present in Ubuntu 14.04 LTS, is an example of such vulnerabilities. 
		We reported this bug as well to the Anchore development team through their Slack
		channel.

\textbf{Rejected CVEs:} There are some CVEs, such as CVE-2017-13753, that are rejected because they are duplicate copies of other CVEs. 
	So, Anchore and Clair does not report those rejected CVEs, but Vuls reports them.

\subsection{Effect Of Update}

As a result of image updating,
scanning results change significantly.
Figure~\ref{fig:graph2} represents the number of vulnerabilities that are detected by Anchore before and after 
image update. 
In fact, this Figure combines the original results of Figure~\ref{fig:graph1} with the results of the image update
experiment.
Clearly, the figure illustrates that when images are updated, the number of vulnerabilities reduces by a
significant number. Furthermore, a mild slope of vulnerabilities after the image update shows that
there is a set of packages that contain vulnerabilities and have not been fixed yet. Also, these
vulnerabilities mostly have \textit{Low, Negligible, or Medium} severity status, meaning that
\textit{high} severity vulnerabilities are prioritized and fixed fast.
Besides that, it is also interesting to note that some images in Figure~\ref{fig:graph2}
do not have update results. This is because some Linux distributions reached end-of-life and
are not being updated anymore.
Despite of the significant drop in the number of vulnerabilities as a result of image updating,
there is still a number of vulnerabilities reported by the scanners. This is due to the
vulnerabilities which do not have fix yet.

\subsection{Effect Of Size Reduction}

Our second approach involves the deletion of unnecessary packages from the images.
We tested our approach on 5 different images covering the spectrum of Figure~\ref{fig:graph1}. We find that
after the size reduction process, sometimes the scanning results deviate only a little from the results
without minimization. While the minimization process results in significant reduction
in the number of vulnerabilities in some cases, we find that in other cases the effect
is negligible. In other words, the image reduction was inconsistent.
According to our analysis, this can be due to two reasons: \rom{1}) the number of
deleted packages
and \rom{2}) the kind of deleted packages. 
For an instance, if the deletion is for a package that includes a lot of vulnerabilities,
that particular deletion naturally results in the drop of number of vulnerabilities.
In other
words, deleting more packages reduces more vulnerabilities. 
For instance, we were able to delete only 21 and 25 packages for 
\textit{bids/ndmg} and \textit{poldracklab/fmriprep:1.2.3} images. Consequently, vulnerabilities
reduced only by 4 and 17 respectively. 
Also, if we delete packages that contain a lot of vulnerabilities, it helps in reducing
vulnerabilities by a significant number. For instance, in case of our experiments
deleting compilers and Linux-kernel-header packages helped to minimize vulnerabilities
by a significant number in \textit{bids/example, bids/freesurfer, and bids/mindboggle:0.0.4-1}. 

\subsection{Combined Effect Of Update and Size Reduction}

Our last experiment includes updating the image and then removing unnecessary packages from it.
Figure~\ref{fig:bargraph} displays the results. 
Our initial expectation was that with the update and size reduction process together, we will be able to
reduce vulnerabilities even more. However,
we analyzed that this is not always true. Again, it depends on which packages are deleted and how
many vulnerabilities they contained. To illustrate, \textit{bids/example} image in Figure~\ref{fig:bargraph}
shows no effect of size reduction along with update process. It has 181 vulnerabilities for both experiments.
Meaning that packages, which we deleted after updating the image, were already vulnerability free. Therefore,
scanning results did not change.
\vspace*{-2mm}
\section{Discussion}

As we noticed that none of the Boutiques and BIDS images at the time of the study are free of vulnerabilities, out of which
so many are high severity vulnerabilities as well. Yet there is not a single image scanner on which we can rely upon for
scanning. Additionally, we cannot update all images because some OS releases, which are used inside images, 
already reached end-of-life and are
no longer getting updates. Furthermore, the minimization of images is a time consuming process. As we have to run
the pipeline to get Reprozip trace that can take up to several hours. Also, the user should have proper knowledge
of running the pipeline because it is image-specific. In addition to that, Reprozip can be only installed
in the images having Python version 2.7.3 or greater, or 3.3 or greater. Above all, there is no guarantee that
the commands that you run to get Reprozip trace covers the whole program, maybe it runs a particular
branch of the program. So, there should be some kind of coverage measurement.
Besides this, as scanners report vulnerabilities according to the versions of the installed packages,
they are likely to miss packages that are not installed using package manager. 
Therefore, we suggest some particular rules that can be
followed to keep container images safe.
\begin{itemize}
	\item Update packages regularly inside images.
	\item Remove unnecessary packages, in particular the ones used for installation (compilers, source packages, etc.).
	\item Choose your base OS image wisely.
	\item Run image scanning tools in CI scripts. For instance Anchore.
	\item Protect your GitHub/DockerHub credentials because if automated builds is set up
in Docker Hub, it can automatically build images from external repositories, for instance GitHub.
\item Minimize dependencies inside images.
\item Avoid static linking because it obfuscates vulnerability scanning.
\item Use the package manager to facilitate vulnerability detection.
\item Use OS releases that have LTS support.
\end{itemize}
\vspace*{-2mm}
\section{Conclusions and Future Work}

In this paper, we performed various experiments to study the security state of the Docker
and Singularity images, which are used in the neuroimaging field. We found out strong correlation
between the number of packages and the number of vulnerabilities in the images, which implies
that the number of vulnerabilities increases with the number of packages. We also found out that
updating images reduces the number of vulnerabilities by a significant number. However, for some
vulnerabilities there are no fixes available yet so the images cannot 
be made totally invulnerable. Continuing with our next two experiments, we analyzed that the
image size reduction process also reduces vulnerabilities a lot. However, we found out that this is not
always true. It depends on two factors: the kind of packages and the number of packages that we are
deleting.

In future work we would like to see how these vulnerabilities can be leveraged
to design attacks from containers. Particularly, we want
to consider web servers and clusters that processes data using containers.

\bibliography{bibliography}
\end{document}

